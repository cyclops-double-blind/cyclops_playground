#!/bin/bash
base_directory=$(realpath $(dirname "$BASH_SOURCE")/..)
sequences=()

## Dataset-specific functions that needs to be injected later.
function sequence_url() {
  echo "Unresolved implementation: $FUNCNAME" >&2
  exit 1
}

function sequence_unzip() {
  echo "Unresolved implementation: $FUNCNAME" >&2
  exit 1
}

function sequence_compile() {
  echo "Unresolved implementation: $FUNCNAME" >&2
  exit 1
}

## Common functions
function sequence_type() {
  echo "${1%%,*}"
}

function sequence_name() {
  echo "${1#*,}"
}

function sequence_basename() {
  local sequence=$(sequence_name $1)
  echo "${sequence:0:5}"
}

function sequence_basepath() {
  echo "$dataset_directory/$(sequence_basename $1)"
}

function sequence_download_size() {
  local length_text=$(curl -sI "$(sequence_url $1)" | grep -i 'Content-Length:')
  local filesize=$(echo $length_text | awk '{print $2}' | tr -d '\r')
  echo "$filesize"
}

function sequence_needs_download() {
  local bag_filename="$(sequence_basepath $1).bag"
  local download_filename="$(sequence_basepath $1).$download_filetype"

  if ! path_exists "$bag_filename" && ! path_exists "$download_filename"; then
    return 0
  else
    return 1
  fi
}

function sequence_bag_all_exist() {
  for element in ${sequences[@]}; do
    if ! path_exists "$(sequence_basepath $element).bag"; then
      return 1
    fi
  done

  return 0
}

function path_exists() {
  if [ -d "$1" ] || [ -f "$1" ]; then
    return 0
  else
    return 1
  fi
}

function draw_progress_bar() {
  local total=$1
  local total_readable=$2

  local current=$3
  local current_readable=$4

  local width=70

  local percent=$((current * 100 / total))
  local completed_width=$((width * percent / 100))

  local bar=""
  for ((i=0; i<completed_width; i++)); do bar+="#"; done
  for ((i=0; i<width-completed_width; i++)); do bar+="-"; done

  local display_text="[$bar] $percent% ($current_readable/$total_readable)"

  echo -ne "\033[K$display_text\r"
}

function download_sequences() {
  local original_sigint=$(trap -p SIGINT)
  local original_sigterm=$(trap -p SIGTERM)

  download_sequences=()
  download_pid=()

  trap download_sequences__cleanup SIGINT SIGTERM
  download_sequences__start

  eval "$original_sigint"
  eval "$original_sigterm"
}

function download_sequences__cleanup() {
  for pid in "${download_pid[@]}"; do
    if kill -0 $pid 2>/dev/null; then
      kill -TERM $pid
      wait $pid
    fi
  done

  for element in "${download_sequences[@]}"; do
    rm $(sequence_basepath $element).$download_filetype
    rm $(sequence_basepath $element).$download_filetype.log
  done

  exit 1
}

function download_sequences__download() {
  for element in ${download_sequences[@]}; do
    local filename="$(sequence_basepath $element).$download_filetype"

    mkdir -p $(dirname ${filename})
    wget -O "${filename}" -o "${filename}.log" $(sequence_url $element) &

    download_pid+=($!)
  done
}

function download_sequences__start() {
  local totalsize=0

  echo "Querying for remote file existence and download size..."
  for index in "${!sequences[@]}"; do
    if ! sequence_needs_download ${sequences[$index]}; then
      continue
    fi

    local filesize=$(sequence_download_size ${sequences[$index]})
    if [[ ! -n "$filesize" ]]; then
      local sequence=$(sequence_name ${sequences[$index]})
      echo "Warning: Could not determine filesize for $sequence. Skipping."
      continue
    fi

    download_sequences+=("${sequences[$index]}")
    totalsize=$((totalsize + filesize))

    draw_progress_bar ${#sequences[@]} ${#sequences[@]} $index $index
  done

  draw_progress_bar \
    ${#sequences[@]} ${#sequences[@]} ${#sequences[@]} ${#sequences[@]}
  echo ""

  if [ ${#download_sequences[@]} -ne 0 ]; then
    echo "Total size: $(numfmt --to=iec --suffix=B <<< "$totalsize")"
  else
    echo "No dataset sequences need to be newly downloaded."
    return
  fi

  download_sequences__download
  download_sequences__display_progress $totalsize
}

function download_sequences__downloaded_size() {
  local size=0

  for element in "${download_sequences[@]}"; do
    local basepath="$(sequence_basepath $element)"
    if [ -f "$basepath.$download_filetype" ]; then
      size=$((size + $(stat -c %s "$basepath.$download_filetype")))
    fi
  done

  echo $size
}

function download_sequences__display_progress() {
  local total=$1
  local total_readable=$(numfmt --to=iec --suffix=B <<< "$total")

  if [ ${#download_pid[@]} -eq 0 ]; then
    return
  fi

  while ps -p ${download_pid[@]} > /dev/null; do
    local current=$(download_sequences__downloaded_size)
    local current_readable=$(numfmt --to=iec --suffix=B <<< "$current")

    draw_progress_bar $total $total_readable $current $current_readable

    sleep 1
  done
}

function compile_sequences() {
  for element in ${sequences[@]}; do
    local basepath=$(sequence_basepath $element)
    if path_exists $basepath.bag; then
      continue
    fi

    if ! path_exists $basepath; then
      sequence_unzip $basepath.$download_filetype $basepath || exit 1
    fi
    sequence_compile $element
  done
}

function cleanup() {
  cleanup_files=()

  for element in ${sequences[@]}; do
    local basepath="$(sequence_basepath $element)"

    if path_exists "$basepath"; then
      cleanup_files+=("$basepath")
    fi
    if path_exists "$basepath.$download_filetype"; then
      cleanup_files+=("$basepath.$download_filetype")
    fi
    if path_exists "$basepath.$download_filetype.log"; then
      cleanup_files+=("$basepath.$download_filetype.log")
    fi
  done

  if [ ${#cleanup_files[@]} -eq 0 ]; then
    return 0;
  fi

  echo "Cleanup temporary files? (Y/N)"

  local response
  read -r response

  response=$(echo "$response" | tr '[:upper:]' '[:lower:]')

  case "$response" in
    y)
      echo "Cleaning up temporary files..."
      for cleanup_file in "${cleanup_files[@]}"; do
        rm -rf $cleanup_file
      done
      ;;
    n)
      echo "Skipping cleanup."
      ;;
    *)
      echo "Invalid response. Please answer 'Y' or 'N' (case insensitive)."
      ;;
  esac
}

show_help() {
  echo "Usage: $0 <dataset_type>"
  echo ""
  echo "Available dataset types (case insensitive):"
  for key in "${!allowed_datasets[@]}"; do
    echo "  - ${allowed_datasets[$key]}"
  done
}

declare -A allowed_datasets
allowed_datasets["euroc"]="EuroC"
allowed_datasets["tum"]="TUM"

if [ $# -eq 0 ]; then
  dataset_type="euroc"
elif [ "$#" -gt 1 ]; then
  show_help
  exit 1
else
  dataset_type="${1,,}"
fi

dataset_name=${allowed_datasets[$dataset_type]}
if [ -z "$dataset_name" ]; then
  show_help
  echo ""
  echo "Unknown dataset type: '$dataset_type'" >&2
  exit 1
fi

source $base_directory/tools/allowed_datasets/${dataset_name}.sh
echo "Downloading ${dataset_name} dataset."

if sequence_bag_all_exist; then
  echo "Sequence bags already exist. Nothing needs to be done."
else
  download_sequences
  compile_sequences
fi

cleanup
